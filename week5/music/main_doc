Overview:

The Main class will have a single instance, which will be referred to
as 'the main instance' or as TMI for short. TMI contains all of the
state of the program.

The important attributes of TMI are:

- playlist_dir: a path name leading to a directory. This directory
  is used to initialize the playlist table. Every file in playlist_dir
  which ends in .playlist will be parsed to a playlist object.

- playlists: the playlist table. This is simply a dict which maps
  playlist names to playlist objects.

- modified_playlists: a set containing the names of the playlists
  which have been modified troughout the duration of the
  program. Playlist names are added in here when adding or removing
  songs, or when creating a new playlist

- current_playlist: a playlist from the playlist table. Most commands
  work in the context of this playlist (like add-song or pprint)

- handlers: a dict which maps command names to their handlers. A
  handler is just a function of no arguments which when called will
  perform the actions of the command.

- player: a Player object which is used to actualy produce the audio
  of the songs. Important invariant: if current_playlist.current_song
  is not None, it will be loaded into the player. If it is None, the
  player will be unloaded.


================================================================================
How to add new commands

Assume you want to add the command 'cmd'. First, you have to create a
handler in init_command_handlers. Lets assume you created the function
cmd_handler, which is going to be the handler for 'cmd'. Then just
decorate cmd_handler with @command_handler('cmd').

***IMPORTANT***: if you are decorating cmd_handler with other
decorators, put command_handler at the top. For example:

========================================
correct way:

@command_handler('cmd')
@end_on_eof
def cmd_handler():
    ...

incorrect way:

@end_on_eof
@command_handler('cmd')
def cmd_handler():
    ...
========================================

In the second approach, the handler that is bound in self.handlers
will not be one which handles eof signals. In other words, in the
second example, the @end_on_eof decorator is useless.

================================================================================
The command loop

The command loop just prints a prompt, accepts a command name,
executes the handler for that command name (it finds the handler
through the 'handlers' attribute of the main instance) and loops
again. The 'keep_command_loop_going' attribute of the main instance
can be set to False by commands which want to kill the program.